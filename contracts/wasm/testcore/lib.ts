// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

import * as wasmlib from "../wasmlib"
import * as sc from "./index";

export function on_call(index: i32): void {
    return wasmlib.onCall(index);
}

export function on_load(): void {
    let exports = new wasmlib.ScExports();
    exports.addFunc(sc.FuncCallOnChain, funcCallOnChainThunk);
    exports.addFunc(sc.FuncCheckContextFromFullEP, funcCheckContextFromFullEPThunk);
    exports.addFunc(sc.FuncDoNothing, funcDoNothingThunk);
    exports.addFunc(sc.FuncGetMintedSupply, funcGetMintedSupplyThunk);
    exports.addFunc(sc.FuncIncCounter, funcIncCounterThunk);
    exports.addFunc(sc.FuncInit, funcInitThunk);
    exports.addFunc(sc.FuncPassTypesFull, funcPassTypesFullThunk);
    exports.addFunc(sc.FuncRunRecursion, funcRunRecursionThunk);
    exports.addFunc(sc.FuncSendToAddress, funcSendToAddressThunk);
    exports.addFunc(sc.FuncSetInt, funcSetIntThunk);
    exports.addFunc(sc.FuncSpawn, funcSpawnThunk);
    exports.addFunc(sc.FuncTestBlockContext1, funcTestBlockContext1Thunk);
    exports.addFunc(sc.FuncTestBlockContext2, funcTestBlockContext2Thunk);
    exports.addFunc(sc.FuncTestCallPanicFullEP, funcTestCallPanicFullEPThunk);
    exports.addFunc(sc.FuncTestCallPanicViewEPFromFull, funcTestCallPanicViewEPFromFullThunk);
    exports.addFunc(sc.FuncTestChainOwnerIDFull, funcTestChainOwnerIDFullThunk);
    exports.addFunc(sc.FuncTestEventLogDeploy, funcTestEventLogDeployThunk);
    exports.addFunc(sc.FuncTestEventLogEventData, funcTestEventLogEventDataThunk);
    exports.addFunc(sc.FuncTestEventLogGenericData, funcTestEventLogGenericDataThunk);
    exports.addFunc(sc.FuncTestPanicFullEP, funcTestPanicFullEPThunk);
    exports.addFunc(sc.FuncWithdrawToChain, funcWithdrawToChainThunk);
    exports.addView(sc.ViewCheckContextFromViewEP, viewCheckContextFromViewEPThunk);
    exports.addView(sc.ViewFibonacci, viewFibonacciThunk);
    exports.addView(sc.ViewGetCounter, viewGetCounterThunk);
    exports.addView(sc.ViewGetInt, viewGetIntThunk);
    exports.addView(sc.ViewGetStringValue, viewGetStringValueThunk);
    exports.addView(sc.ViewJustView, viewJustViewThunk);
    exports.addView(sc.ViewPassTypesView, viewPassTypesViewThunk);
    exports.addView(sc.ViewTestCallPanicViewEPFromView, viewTestCallPanicViewEPFromViewThunk);
    exports.addView(sc.ViewTestChainOwnerIDView, viewTestChainOwnerIDViewThunk);
    exports.addView(sc.ViewTestPanicViewEP, viewTestPanicViewEPThunk);
    exports.addView(sc.ViewTestSandboxCall, viewTestSandboxCallThunk);

    for (let i = 0; i < sc.keyMap.length; i++) {
        sc.idxMap[i] = wasmlib.Key32.fromString(sc.keyMap[i]);
    }
}

function funcCallOnChainThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcCallOnChain");
    let f = new sc.CallOnChainContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.intValue().exists(), "missing mandatory intValue")
    sc.funcCallOnChain(ctx, f);
    ctx.log("testcore.funcCallOnChain ok");
}

function funcCheckContextFromFullEPThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcCheckContextFromFullEP");
    let f = new sc.CheckContextFromFullEPContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.agentID().exists(), "missing mandatory agentID")
    ctx.require(f.params.caller().exists(), "missing mandatory caller")
    ctx.require(f.params.chainID().exists(), "missing mandatory chainID")
    ctx.require(f.params.chainOwnerID().exists(), "missing mandatory chainOwnerID")
    ctx.require(f.params.contractCreator().exists(), "missing mandatory contractCreator")
    sc.funcCheckContextFromFullEP(ctx, f);
    ctx.log("testcore.funcCheckContextFromFullEP ok");
}

function funcDoNothingThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcDoNothing");
    let f = new sc.DoNothingContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcDoNothing(ctx, f);
    ctx.log("testcore.funcDoNothing ok");
}

function funcGetMintedSupplyThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcGetMintedSupply");
    let f = new sc.GetMintedSupplyContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcGetMintedSupply(ctx, f);
    ctx.log("testcore.funcGetMintedSupply ok");
}

function funcIncCounterThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcIncCounter");
    let f = new sc.IncCounterContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcIncCounter(ctx, f);
    ctx.log("testcore.funcIncCounter ok");
}

function funcInitThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcInit");
    let f = new sc.InitContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcInit(ctx, f);
    ctx.log("testcore.funcInit ok");
}

function funcPassTypesFullThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcPassTypesFull");
    let f = new sc.PassTypesFullContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.address().exists(), "missing mandatory address")
    ctx.require(f.params.agentID().exists(), "missing mandatory agentID")
    ctx.require(f.params.chainID().exists(), "missing mandatory chainID")
    ctx.require(f.params.contractID().exists(), "missing mandatory contractID")
    ctx.require(f.params.hash().exists(), "missing mandatory hash")
    ctx.require(f.params.hname().exists(), "missing mandatory hname")
    ctx.require(f.params.hnameZero().exists(), "missing mandatory hnameZero")
    ctx.require(f.params.int64().exists(), "missing mandatory int64")
    ctx.require(f.params.int64Zero().exists(), "missing mandatory int64Zero")
    ctx.require(f.params.string().exists(), "missing mandatory string")
    ctx.require(f.params.stringZero().exists(), "missing mandatory stringZero")
    sc.funcPassTypesFull(ctx, f);
    ctx.log("testcore.funcPassTypesFull ok");
}

function funcRunRecursionThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcRunRecursion");
    let f = new sc.RunRecursionContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.intValue().exists(), "missing mandatory intValue")
    sc.funcRunRecursion(ctx, f);
    ctx.log("testcore.funcRunRecursion ok");
}

function funcSendToAddressThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcSendToAddress");
    ctx.require(ctx.caller().equals(ctx.contractCreator()), "no permission");

    let f = new sc.SendToAddressContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.address().exists(), "missing mandatory address")
    sc.funcSendToAddress(ctx, f);
    ctx.log("testcore.funcSendToAddress ok");
}

function funcSetIntThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcSetInt");
    let f = new sc.SetIntContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.intValue().exists(), "missing mandatory intValue")
    ctx.require(f.params.name().exists(), "missing mandatory name")
    sc.funcSetInt(ctx, f);
    ctx.log("testcore.funcSetInt ok");
}

function funcSpawnThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcSpawn");
    let f = new sc.SpawnContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.progHash().exists(), "missing mandatory progHash")
    sc.funcSpawn(ctx, f);
    ctx.log("testcore.funcSpawn ok");
}

function funcTestBlockContext1Thunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestBlockContext1");
    let f = new sc.TestBlockContext1Context();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestBlockContext1(ctx, f);
    ctx.log("testcore.funcTestBlockContext1 ok");
}

function funcTestBlockContext2Thunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestBlockContext2");
    let f = new sc.TestBlockContext2Context();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestBlockContext2(ctx, f);
    ctx.log("testcore.funcTestBlockContext2 ok");
}

function funcTestCallPanicFullEPThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestCallPanicFullEP");
    let f = new sc.TestCallPanicFullEPContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestCallPanicFullEP(ctx, f);
    ctx.log("testcore.funcTestCallPanicFullEP ok");
}

function funcTestCallPanicViewEPFromFullThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestCallPanicViewEPFromFull");
    let f = new sc.TestCallPanicViewEPFromFullContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestCallPanicViewEPFromFull(ctx, f);
    ctx.log("testcore.funcTestCallPanicViewEPFromFull ok");
}

function funcTestChainOwnerIDFullThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestChainOwnerIDFull");
    let f = new sc.TestChainOwnerIDFullContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestChainOwnerIDFull(ctx, f);
    ctx.log("testcore.funcTestChainOwnerIDFull ok");
}

function funcTestEventLogDeployThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestEventLogDeploy");
    let f = new sc.TestEventLogDeployContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestEventLogDeploy(ctx, f);
    ctx.log("testcore.funcTestEventLogDeploy ok");
}

function funcTestEventLogEventDataThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestEventLogEventData");
    let f = new sc.TestEventLogEventDataContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestEventLogEventData(ctx, f);
    ctx.log("testcore.funcTestEventLogEventData ok");
}

function funcTestEventLogGenericDataThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestEventLogGenericData");
    let f = new sc.TestEventLogGenericDataContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.counter().exists(), "missing mandatory counter")
    sc.funcTestEventLogGenericData(ctx, f);
    ctx.log("testcore.funcTestEventLogGenericData ok");
}

function funcTestPanicFullEPThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestPanicFullEP");
    let f = new sc.TestPanicFullEPContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestPanicFullEP(ctx, f);
    ctx.log("testcore.funcTestPanicFullEP ok");
}

function funcWithdrawToChainThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcWithdrawToChain");
    let f = new sc.WithdrawToChainContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.chainID().exists(), "missing mandatory chainID")
    sc.funcWithdrawToChain(ctx, f);
    ctx.log("testcore.funcWithdrawToChain ok");
}

function viewCheckContextFromViewEPThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewCheckContextFromViewEP");
    let f = new sc.CheckContextFromViewEPContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.agentID().exists(), "missing mandatory agentID")
    ctx.require(f.params.chainID().exists(), "missing mandatory chainID")
    ctx.require(f.params.chainOwnerID().exists(), "missing mandatory chainOwnerID")
    ctx.require(f.params.contractCreator().exists(), "missing mandatory contractCreator")
    sc.viewCheckContextFromViewEP(ctx, f);
    ctx.log("testcore.viewCheckContextFromViewEP ok");
}

function viewFibonacciThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewFibonacci");
    let f = new sc.FibonacciContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.intValue().exists(), "missing mandatory intValue")
    sc.viewFibonacci(ctx, f);
    ctx.log("testcore.viewFibonacci ok");
}

function viewGetCounterThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewGetCounter");
    let f = new sc.GetCounterContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.viewGetCounter(ctx, f);
    ctx.log("testcore.viewGetCounter ok");
}

function viewGetIntThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewGetInt");
    let f = new sc.GetIntContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.name().exists(), "missing mandatory name")
    sc.viewGetInt(ctx, f);
    ctx.log("testcore.viewGetInt ok");
}

function viewGetStringValueThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewGetStringValue");
    let f = new sc.GetStringValueContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.varName().exists(), "missing mandatory varName")
    sc.viewGetStringValue(ctx, f);
    ctx.log("testcore.viewGetStringValue ok");
}

function viewJustViewThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewJustView");
    let f = new sc.JustViewContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.viewJustView(ctx, f);
    ctx.log("testcore.viewJustView ok");
}

function viewPassTypesViewThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewPassTypesView");
    let f = new sc.PassTypesViewContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.address().exists(), "missing mandatory address")
    ctx.require(f.params.agentID().exists(), "missing mandatory agentID")
    ctx.require(f.params.chainID().exists(), "missing mandatory chainID")
    ctx.require(f.params.contractID().exists(), "missing mandatory contractID")
    ctx.require(f.params.hash().exists(), "missing mandatory hash")
    ctx.require(f.params.hname().exists(), "missing mandatory hname")
    ctx.require(f.params.hnameZero().exists(), "missing mandatory hnameZero")
    ctx.require(f.params.int64().exists(), "missing mandatory int64")
    ctx.require(f.params.int64Zero().exists(), "missing mandatory int64Zero")
    ctx.require(f.params.string().exists(), "missing mandatory string")
    ctx.require(f.params.stringZero().exists(), "missing mandatory stringZero")
    sc.viewPassTypesView(ctx, f);
    ctx.log("testcore.viewPassTypesView ok");
}

function viewTestCallPanicViewEPFromViewThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewTestCallPanicViewEPFromView");
    let f = new sc.TestCallPanicViewEPFromViewContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.viewTestCallPanicViewEPFromView(ctx, f);
    ctx.log("testcore.viewTestCallPanicViewEPFromView ok");
}

function viewTestChainOwnerIDViewThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewTestChainOwnerIDView");
    let f = new sc.TestChainOwnerIDViewContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.viewTestChainOwnerIDView(ctx, f);
    ctx.log("testcore.viewTestChainOwnerIDView ok");
}

function viewTestPanicViewEPThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewTestPanicViewEP");
    let f = new sc.TestPanicViewEPContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.viewTestPanicViewEP(ctx, f);
    ctx.log("testcore.viewTestPanicViewEP ok");
}

function viewTestSandboxCallThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewTestSandboxCall");
    let f = new sc.TestSandboxCallContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.viewTestSandboxCall(ctx, f);
    ctx.log("testcore.viewTestSandboxCall ok");
}
